name: Compile AutoIt Script

on:
  push:
    branches: [ main ]
    paths:
      - 'src/**/*.au3'

######################################################################### repo permissions (no token)

#permissions:
#  contents: write

######################################################################### jobs

jobs:
  compile:
    runs-on: windows-2022 # Autoit tool does not support >=2025
    timeout-minutes: 3    # Maximum compilation time
    env:
      SCRIPT_NAME: myLogin
      SCRIPT_PATH: 'src\'
      ENABLE_SIGNPATH: 'true'
      ENABLE_VIRUSTOTAL: 'true'
      
    steps:
######################################################################### checkout
    - name: Checkout code
      uses: actions/checkout@v5
      with:
        token: ${{ secrets.AUTOIT_DEPLOY_TOKEN }}
        # Download only the necessary files
        sparse-checkout: |
          src/
          lang/
        # no requerid
        ssh-strict: false
        show-progress: false
            
######################################################################### get upd/version

    - name: Get and update version
      run: |
        filePath="$GITHUB_WORKSPACE\${{ env.SCRIPT_PATH }}${{ env.SCRIPT_NAME }}.au3"
        
        # Verify that the file exists
        if [ ! -f "$filePath" ]; then
          echo "::error::File not found: $filePath"
          exit 1
        fi
        
        # Temporarily convert to LF for processing (we'll save with CRLF at the end)
        tempContent=$(cat "$filePath" | tr -d '\r')
        
        # Extract current version
        if [[ ! "$tempContent" =~ Const[[:space:]]+\$g_sVersion[[:space:]]*=[[:space:]]*\"([0-9]+)\.([0-9]+)\" ]]; then
          echo "::error::Version pattern not found in $filePath"
          echo "::debug::Line with version:"
          echo "$tempContent" | grep -m1 "Const \$g_sVersion" || echo "Not found"
          exit 1
        fi
        
        major=${BASH_REMATCH[1]}
        minor=${BASH_REMATCH[2]}
        old_version="${major}.${minor}"
        
        # Calculate new version
        if (( minor >= 9 )); then
          newVersion="$((major + 1)).0"
        else
          newVersion="${major}.$((minor + 1))"
        fi
        
        # Update CONST y pragmas
        updatedContent=$(echo "$tempContent" | \
        awk -v new="$newVersion" '
          /Const[[:space:]]+\$g_sVersion[[:space:]]*=/ {sub(/"([0-9]+\.){1}[0-9]+"/, "\"" new "\"")}
          {print}' | \
        sed -E "s/(#pragma compile\((ProductVersion|FileVersion),[[:space:]]*)[0-9]+\.[0-9]+(\))/\1${newVersion}\3/g")
        
        # Restore CRLF and write the file
        echo "$updatedContent" | sed 's/$/\r/' > "$filePath"
        
        # Export environment variables
        echo "OLD_VERSION=${old_version}" >> $GITHUB_ENV
        echo "NEW_VERSION=$newVersion" >> $GITHUB_ENV
      shell: bash
        
######################################################################### autoit tool

    - name: Setup AutoIt Tool
      id: autoit_tool
      uses: whatk233/setup-autoit-compiler-toolkit@v0.3
      continue-on-error: true

######################################################################### autoit setup

    - name: Fallback AutoIt Setup
      if: steps.autoit_tool.outcome == 'failure'
      run: |
        # Download and install AutoIt
        $installerPath = "$env:TEMP\autoit-installer.exe"
        Invoke-WebRequest -Uri "https://www.autoitscript.com/cgi-bin/getfile.pl?autoit3/autoit-v3-setup.exe" -OutFile $installerPath
        Start-Process -FilePath $installerPath -ArgumentList "/S" -Wait
        
        # Verify AutoIt installation
        $aut2exePath = "C:\Program Files (x86)\AutoIt3\Aut2Exe\Aut2Exe.exe"
        echo "AUT2EXE=$aut2exePath" >> $env:GITHUB_ENV
        
        if (-not (Test-Path "$aut2exePath")) {
          echo "::error::AutoIt installation failed"
          exit 1
        }
        
######################################################################### compile au3/exe

    - name: Compile with Aut2Exe
      run: |
        $scriptPath = "$env:GITHUB_WORKSPACE\${{ env.SCRIPT_PATH }}${{ env.SCRIPT_NAME }}.au3"
        $outputPath = "$env:GITHUB_WORKSPACE\${{ env.SCRIPT_NAME }}.exe"

        # Verify script exists
        if (-not (Test-Path $scriptPath)) {
          echo "::error::Script not found at $scriptPath"
          exit 1
        }
        
        # Determine which Aut2Exe to use
        $aut2exePath = if (Test-Path "$env:AUTOIT_COMPILER_TOOLKIT\Aut2Exe\Aut2exe.exe") {
          "$env:AUTOIT_COMPILER_TOOLKIT\Aut2Exe\Aut2exe.exe"
        } else {
          "${{ env.AUT2EXE }}"
        }
        
        # Compile with detailed output
        & "$aut2exePath" /in "$scriptPath" /out "$outputPath" /comp 0 /nopack | 
        Where-Object { $_ -match "error" } | Write-Error
        
        # Verify compilation
        if (-not (Test-Path $outputPath)) {
          echo "::error::Compilation failed - No output file created"
          exit 1
        }
        echo "::notice::Compilation successful - Executable size: $((Get-Item $outputPath).Length) bytes"

######################################################################### SignPath signature

    - name: Sign executable with SignPath
      if: env.ENABLE_SIGNPATH == 'true'
      run: |
        # Install the SignPath PowerShell module if it is not present
        if (-not (Get-Module -ListAvailable -Name SignPath)) {
          Install-Module -Name SignPath -Force -Scope CurrentUser -AllowClobber
        }
        Import-Module SignPath
        
        # Send signature request
        try {
          Submit-SigningRequest `
            -InputArtifactPath "${{ env.SCRIPT_NAME }}.exe" `
            -ApiToken "${{ secrets.SIGNPATH_TOKEN }}" `
            -OrganizationId "${{ secrets.SIGNPATH_ORG_ID }}" `
            -ProjectSlug "${{ env.SCRIPT_NAME }}" `
            -SigningPolicySlug "${{ env.SCRIPT_NAME }}" `
            -OutputArtifactPath "${{ env.SCRIPT_NAME }}.signed.exe" `
            -WaitForCompletion

          # Replace the unsigned executable with the signed one
          Move-Item -Path "${{ env.SCRIPT_NAME }}.signed.exe" -Destination "${{ env.SCRIPT_NAME }}.exe" -Force
          echo "::notice::Executable signed successfully"
        } catch {
          echo "::error::Failed to sign executable: $_"
          exit 1
        }
        
######################################################################### GPG signature

    - name: Sign executable with GPG
      run: |
        # Import private key
        echo "${{ secrets.GPG_PRIVATE_KEY }}" | gpg --batch --import
        
        # Sign the executable
        gpg --batch --yes --pinentry-mode loopback `
          --passphrase "${{ secrets.GPG_PASSPHRASE }}" `
          --local-user "${{ secrets.GPG_KEY_ID }}" `
          --output "${{ env.SCRIPT_NAME }}.exe.sig" `
          --detach-sig "${{ env.SCRIPT_NAME }}.exe"
        
        # Verify the signature
        gpg --verify "${{ env.SCRIPT_NAME }}.exe.sig" "${{ env.SCRIPT_NAME }}.exe"
        
        if ($LASTEXITCODE -ne 0) {
          echo "::error::GPG signature verification failed"
          exit 1
        }
        
######################################################################### compress files

    - name: Create ZIP for releases
      run: 7z a -tzip -bd -mx=9 "${{ env.SCRIPT_NAME }}${{ env.NEW_VERSION }}.zip" "${{ env.SCRIPT_NAME }}.exe" "lang"
      
######################################################################### compress files (optional)

    #- name: Upload artifact
    #  uses: actions/upload-artifact@v4
    #  with:
    #    name: ${{ env.SCRIPT_NAME }}${{ env.NEW_VERSION }}
    #    path: |
    #      ${{ env.SCRIPT_NAME }}.exe
    #      lang/*.ini

######################################################################### config. git/gpg/commit/tag

    - name: Config. Git/GPG/Commit/Tag
      run: |
        # Configure GPG to sign commits
        git config --global user.signingkey "${{ secrets.GPG_KEY_ID }}"
        git config --global commit.gpgsign true
        git config --global tag.gpgsign true

        # Configure the name and email for the commits
        #git config --global user.name "GitHub Actions"
        #git config --global user.email "actions@github.com"
        git config --global user.name "mlibre2"
        git config --global user.email "112137590+mlibre2@users.noreply.github.com"
        
        # Commit changes
        git add "${{ env.SCRIPT_PATH }}${{ env.SCRIPT_NAME }}.au3"
        
        # -m = "actions-user" / -S = forces signing "redundant if commit.gpgsign=true, but useful for debugging"
        git commit -S -m "⬆️ Auto-update version to ${{ env.NEW_VERSION }} [skip ci]"
        git push origin HEAD:main
        
        # Create tag (-a = "actions-user" / -s = create a tag signed with GPG key)
        git tag -s "${{ env.NEW_VERSION }}" -m "${{ env.NEW_VERSION }}"
        git push origin "${{ env.NEW_VERSION }}"

######################################################################### create Release

    - name: Create GitHub Release
      uses: softprops/action-gh-release@v2
      env:
        GITHUB_TOKEN: ${{ secrets.AUTOIT_DEPLOY_TOKEN }}
      with:
        tag_name: ${{ env.NEW_VERSION }}
        files: |
          ${{ env.SCRIPT_NAME }}${{ env.NEW_VERSION }}.zip
          ${{ env.SCRIPT_NAME }}.exe.sig

######################################################################### virustotal

    - name: Analyze URL with VirusTotal
      if: env.ENABLE_VIRUSTOTAL == 'true'
      run: |
        $ZIP_URL = "https://github.com/${{ github.repository }}/releases/download/${{ env.NEW_VERSION }}/${{ env.SCRIPT_NAME }}${{ env.NEW_VERSION }}.zip"
        
        # Headers API v3
        $headers = @{
          "x-apikey" = "${{ secrets.VIRUSTOTAL_API_KEY }}"
          "Accept" = "application/json"
          "Content-Type" = "application/x-www-form-urlencoded"
        }
        
        try {
          # Correctly encode the URL for the request body
          $encodedUrl = [System.Web.HttpUtility]::UrlEncode($ZIP_URL)
          $postParams = "url=$encodedUrl"
          
          # Send POST request
          $response = Invoke-RestMethod -Uri "https://www.virustotal.com/api/v3/urls" `
                                       -Method Post `
                                       -Headers $headers `
                                       -Body $postParams
                                       
          # Process the response
          $analysisId = $response.data.id

          # Removes 'u-' prefix and numeric suffix
          $urlId = $analysisId -replace '^u-|-\d+$'
          
          # Build report URL
          $VT_GUI_URL = "https://www.virustotal.com/gui/url/$urlId"
          
          # Save the URL in environment variables
          Add-Content -Path $env:GITHUB_ENV -Value "VT_GUI_URL=$VT_GUI_URL"
          Write-Output "VirusTotal Report URL: $VT_GUI_URL"
          
        } catch {
          # Detailed error handling
          $errorDetails = $_
          if ($_.Exception.Response) {
            $streamReader = [System.IO.StreamReader]::new($_.Exception.Response.GetResponseStream())
            $errorResponse = $streamReader.ReadToEnd() | ConvertFrom-Json
            $streamReader.Close()
            Write-Error "VirusTotal API Error: $($errorResponse.error.message)"
          } else {
            Write-Error "Error general: $($errorDetails.Exception.Message)"
          }
          exit 1
        }

######################################################################### get commit message

    - name: Get/Save commit msg
      run: |
        $commitMsg = "${{ github.event.head_commit.message }}"

        # split a text string into multiple parts using line breaks as separators
        $lines = $commitMsg -split "`n" # `n represents the line break character

        # Cleaning up empty lines and whitespace
        $lines = $lines | Where-Object { $_ -ne "" } | ForEach-Object { $_.Trim() }

        #  debug...
        #  $lines[0] = "Update myLogin.au3"
        #  $lines[1] = "" (empty line)
        #  $lines[2] = "Fixed special"
        #  $lines[3] = "" (empty line)
        #  $lines[4] = "- New update"
        #  $lines[5] = "- Fixed lines"
        
        # Initialize variables
        $title = ""
        $description = ""
        
        # Only proceed if there are enough lines
        if ($lines -and $lines.Count -ge 3) {
            $title = $lines[2]
            
            if ($lines.Count -ge 5) {
                $description = $lines[4..($lines.Count-1)] -join "`n"
            }
        }

        # Only set environment variables if title exists
        if ($title) {
            "COMMIT_TITLE=$($title -replace "`n", " ")" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
            "COMMIT_DESCRIPTION<<EOF" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
            $description | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
            "EOF" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
        }
        
######################################################################### update release notes

    - name: Update release notes
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.AUTOIT_DEPLOY_TOKEN }}
        script: |
          // Get the existing release by tag
          const { data: release } = await github.rest.repos.getReleaseByTag({
            owner: context.repo.owner,
            repo: context.repo.repo,
            tag: process.env.NEW_VERSION
          });
          
          const vtMessage = `- [${process.env.ENABLE_VIRUSTOTAL === 'true' ? 'x' : ' '}] [VirusTotal](${process.env.ENABLE_VIRUSTOTAL === 'true' ? process.env.VT_GUI_URL + '?nocache=1' : '#'})`;
          
          // Build the new body
          const newBody = `
          # :building_construction: ${process.env.COMMIT_TITLE} <img align="right" width="32" height="32" alt="Ico" src="https://github.com/user-attachments/assets/c8c08b6a-927c-4278-917a-c23b10e6491d" />
          
          ${process.env.COMMIT_DESCRIPTION}
          
          ## :recycle: Full Changelog
          
          - Versions: [\`${process.env.OLD_VERSION}...${process.env.NEW_VERSION}\`](https://github.com/${context.repo.owner}/${context.repo.repo}/compare/${process.env.OLD_VERSION}...${process.env.NEW_VERSION})
          
          ## :beginner: Security vendors' analysis

          ${vtMessage}
          
          ## :inbox_tray: Downloads
          
          [![GitHub release (by tag)](https://img.shields.io/github/downloads/${context.repo.owner}/${context.repo.repo}/${process.env.NEW_VERSION}/total?style=for-the-badge)](https://github.com/${context.repo.owner}/${context.repo.repo}/releases/download/${process.env.NEW_VERSION}/${process.env.SCRIPT_NAME}${process.env.NEW_VERSION}.zip)
          `;
          
          // Update release
          await github.rest.repos.updateRelease({
            owner: context.repo.owner,
            repo: context.repo.repo,
            release_id: release.id,
            body: newBody
          });


######################################################################### add reactions
      
    - name: Add random reactions to release
      uses: actions/github-script@v7
      with:
        script: |
          const { data: release } = await github.rest.repos.getReleaseByTag({
            owner: context.repo.owner,
            repo: context.repo.repo,
            tag: '${{ env.NEW_VERSION }}'
          });
          
          // Reactions allowed by GitHub API for releases
          const reactions = ['+1', 'heart', 'hooray', 'rocket', 'eyes', 'laugh']
            .sort(() => Math.random() - 0.5)  // Shuffle array
            .slice(0, 2);  // Take first 2 elements
            
          console.log(`Adding reactions: ${reactions.join(' ... ')}`);
          
          // Add reactions in parallel
          await Promise.all(reactions.map(content => 
            github.rest.reactions.createForRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: release.id,
              content
            })
          ));
