name: Compile AutoIt Script

on:
  push:
    branches: [ main ]
    paths:
      - 'src/**/*.au3'

######################################################################### repo permissions (no token)

#permissions:
#  contents: write

######################################################################### jobs

jobs:
  compile:
    runs-on: windows-2022 # Autoit tool does not support >=2025
    timeout-minutes: 3    # Maximum compilation time
    env:
      SCRIPT_NAME: myLogin
      SCRIPT_PATH: 'src\'
      ENABLE_SIGNPATH: 'true'
      ENABLE_VIRUSTOTAL: 'true'
      
    steps:
######################################################################### checkout
    - name: Checkout code
      uses: actions/checkout@v5
      with:
        token: ${{ secrets.AUTOIT_DEPLOY_TOKEN }}
        # Download only the necessary files
        sparse-checkout: src/
        # no requerid
        ssh-strict: false
        show-progress: false
            
######################################################################### get upd/version

    - name: Get and update version
      run: |
        filePath="$GITHUB_WORKSPACE\${{ env.SCRIPT_PATH }}${{ env.SCRIPT_NAME }}.au3"
        
        # Verify that the file exists
        if [ ! -f "$filePath" ]; then
          echo "::error::File not found: $filePath"
          exit 1
        fi
        
        # Temporarily convert to LF for processing (we'll save with CRLF at the end)
        tempContent=$(cat "$filePath" | tr -d '\r')
        
        # Extract current version
        if [[ ! "$tempContent" =~ Const[[:space:]]+\$g_sVersion[[:space:]]*=[[:space:]]*\"([0-9]+)\.([0-9]+)\" ]]; then
          echo "::error::Version pattern not found in $filePath"
          echo "::debug::Line with version:"
          echo "$tempContent" | grep -m1 "Const \$g_sVersion" || echo "Not found"
          exit 1
        fi
        
        major=${BASH_REMATCH[1]}
        minor=${BASH_REMATCH[2]}
        old_version="${major}.${minor}"
        
        # Calculate new version
        if (( minor >= 9 )); then
          newVersion="$((major + 1)).0"
        else
          newVersion="${major}.$((minor + 1))"
        fi
        
        # Update CONST y pragmas
        updatedContent=$(echo "$tempContent" | \
        awk -v new="$newVersion" '
          /Const[[:space:]]+\$g_sVersion[[:space:]]*=/ {sub(/"([0-9]+\.){1}[0-9]+"/, "\"" new "\"")}
          {print}' | \
        sed -E "s/(#pragma compile\((ProductVersion|FileVersion),[[:space:]]*)[0-9]+\.[0-9]+(\))/\1${newVersion}\3/g")
        
        # Restore CRLF and write the file
        echo "$updatedContent" | sed 's/$/\r/' > "$filePath"
        
        # Export environment variables
        echo "OLD_VERSION=${old_version}" >> $GITHUB_ENV
        echo "NEW_VERSION=$newVersion" >> $GITHUB_ENV
      shell: bash
        
######################################################################### autoit tool

    - name: Setup AutoIt Tool
      id: autoit_tool
      uses: whatk233/setup-autoit-compiler-toolkit@v0.3
      continue-on-error: true

######################################################################### autoit setup

    - name: Fallback AutoIt Setup
      if: steps.autoit_tool.outcome == 'failure'
      run: |
        # Download and install AutoIt
        $installerPath = "$env:TEMP\autoit-installer.exe"
        Invoke-WebRequest -Uri "https://www.autoitscript.com/cgi-bin/getfile.pl?autoit3/autoit-v3-setup.exe" -OutFile $installerPath
        Start-Process -FilePath $installerPath -ArgumentList "/S" -Wait
        
        # Verify AutoIt installation
        $aut2exePath = "C:\Program Files (x86)\AutoIt3\Aut2Exe\Aut2Exe.exe"
        echo "AUT2EXE=$aut2exePath" >> $env:GITHUB_ENV
        
        if (-not (Test-Path "$aut2exePath")) {
          echo "::error::AutoIt installation failed"
          exit 1
        }
        
######################################################################### compile au3/exe

    - name: Compile with Aut2Exe
      run: |
        $scriptPath = "$env:GITHUB_WORKSPACE\${{ env.SCRIPT_PATH }}${{ env.SCRIPT_NAME }}.au3"
        $outputPath = "$env:GITHUB_WORKSPACE\${{ env.SCRIPT_NAME }}.exe"

        # Verify script exists
        if (-not (Test-Path $scriptPath)) {
          echo "::error::Script not found at $scriptPath"
          exit 1
        }
        
        # Determine which Aut2Exe to use
        $aut2exePath = if (Test-Path "$env:AUTOIT_COMPILER_TOOLKIT\Aut2Exe\Aut2exe.exe") {
          "$env:AUTOIT_COMPILER_TOOLKIT\Aut2Exe\Aut2exe.exe"
        } else {
          "${{ env.AUT2EXE }}"
        }
        
        # Compile with detailed output
        & "$aut2exePath" /in "$scriptPath" /out "$outputPath" /comp 0 /nopack | 
        Where-Object { $_ -match "error" } | Write-Error
        
        # Verify compilation
        if (-not (Test-Path $outputPath)) {
          echo "::error::Compilation failed - No output file created"
          exit 1
        }
        echo "::notice::Compilation successful - Executable size: $((Get-Item $outputPath).Length) bytes"

######################################################################### SignPath executable

    - name: Sign executable with SignPath
      if: env.ENABLE_SIGNPATH == 'true'
      run: |
        # Install the SignPath PowerShell module if it is not present
        if (-not (Get-Module -ListAvailable -Name SignPath)) {
          Install-Module -Name SignPath -Force -Scope CurrentUser -AllowClobber
        }
        Import-Module SignPath
        
        # Send signature request EXE
        try {
          Submit-SigningRequest `
            -InputArtifactPath "${{ env.SCRIPT_NAME }}.exe" `
            -ApiToken "${{ secrets.SIGNPATH_TOKEN }}" `
            -OrganizationId "${{ secrets.SIGNPATH_ORG_ID }}" `
            -ProjectSlug "${{ env.SCRIPT_NAME }}" `
            -SigningPolicySlug "${{ env.SCRIPT_NAME }}" `
            -OutputArtifactPath "${{ env.SCRIPT_NAME }}.signed.exe" `
            -WaitForCompletion

          # Replace the unsigned executable with the signed one
          Move-Item -Path "${{ env.SCRIPT_NAME }}.signed.exe" -Destination "${{ env.SCRIPT_NAME }}.exe" -Force
          echo "::notice::Executable signed successfully"
        } catch {
          echo "::error::Failed to sign executable: $_"
          exit 1
        }

######################################################################### Inno Setup installer

    - name: Create Inno Setup script
      run: |
        $issContent = @"
        [Setup]
        AppName=${{ env.SCRIPT_NAME }}
        AppVersion=${{ env.NEW_VERSION }}
        VersionInfoVersion=${{ env.NEW_VERSION }}.0.0
        AppVerName=${{ env.SCRIPT_NAME }} v${{ env.NEW_VERSION }}
        AppComments=${{ env.SCRIPT_NAME }} - Inno Setup
        AppCopyright=© by mlibre2 - Open source project on GitHub
        DefaultDirName={autopf}\${{ env.SCRIPT_NAME }}
        DefaultGroupName=${{ env.SCRIPT_NAME }}
        AppPublisher=GitHub@mlibre2
        AppPublisherURL=https://github.com/${{ github.repository }}/
        AppReadmeFile=https://github.com/${{ github.repository }}/blob/main/README.md
        AppSupportURL=https://github.com/${{ github.repository }}/issues
        AppUpdatesURL=https://github.com/${{ github.repository }}/releases
        DisableWelcomePage=no
        DisableProgramGroupPage=yes
        OutputDir=.
        OutputBaseFilename=${{ env.SCRIPT_NAME }}${{ env.NEW_VERSION }}_Setup
        SolidCompression=yes
        SetupIconFile=C:\Windows\SystemApps\Microsoft.Windows.SecHealthUI_cw5n1h2txyewy\Assets\Threat.contrast-white.ico
        ShowLanguageDialog=yes

        [Languages]
        Name: "en"; MessagesFile: "compiler:Default.isl"
        Name: "es"; MessagesFile: "compiler:Languages\Spanish.isl"

        [Tasks]
        Name: desktopicon; Description: "{cm:CreateDesktopIcon}"; GroupDescription: "{cm:AdditionalIcons}"; Flags: unchecked
        
        [Dirs]
        Name: "{app}"; Permissions: users-modify
        
        [Files]
        Source: "$env:GITHUB_WORKSPACE\${{ env.SCRIPT_NAME }}.exe"; DestDir: "{app}"; Flags: ignoreversion
        Source: "$env:GITHUB_WORKSPACE\${{ env.SCRIPT_PATH }}config.ini"; DestDir: "{app}"; Flags: onlyifdoesntexist
        Source: "$env:GITHUB_WORKSPACE\${{ env.SCRIPT_PATH }}lang\*"; DestDir: "{app}\lang"; Flags: recursesubdirs onlyifdoesntexist

        ; Temporary files for upgrade (only copied if it is an upgrade)
        Source: "$env:GITHUB_WORKSPACE\${{ env.SCRIPT_PATH }}config.ini"; DestDir: "{app}\myLoginUpdate"; Flags: ignoreversion; Check: IsUpgrade
        Source: "$env:GITHUB_WORKSPACE\${{ env.SCRIPT_PATH }}lang\*"; DestDir: "{app}\myLoginUpdate\lang"; Flags: ignoreversion recursesubdirs; Check: IsUpgrade

        [Icons]
        Name: "{commondesktop}\${{ env.SCRIPT_NAME }}"; Filename: "{app}\${{ env.SCRIPT_NAME }}.exe"; Comment: "${{ env.SCRIPT_NAME }}"; Tasks: desktopicon
        
        [Run]
        Filename: "{app}\${{ env.SCRIPT_NAME }}.exe"; Flags: postinstall nowait skipifsilent
        
        [UninstallRun]
        Filename: "{app}\${{ env.SCRIPT_NAME }}.exe"; Parameters: "/uninstall"; RunOnceId: "${{ env.SCRIPT_NAME }}Uninstaller"
        
        [Code]
        var
          IsUpgradeMode: Boolean;

        function InitializeSetup(): Boolean;
        begin
          IsUpgradeMode := RegKeyExists(HKLM, 'Software\Microsoft\Windows\CurrentVersion\Uninstall\${{ env.SCRIPT_NAME }}_is1');
          Result := True;
        end;
        
        function IsUpgrade: Boolean;
        begin
          Result := IsUpgradeMode;
        end;

        procedure CurStepChanged(CurStep: TSetupStep);
        var
          ResultCode: Integer;
          FindRec: TFindRec;
          LangPath: String;
          TmpLangPath: String;
        begin
          if (CurStep = ssPostInstall) and IsUpgrade then
          begin
            // Only run if temporary files exist
            if FileExists(ExpandConstant('{app}\myLoginUpdate\config.ini')) then
            begin
              Exec(
                ExpandConstant('{app}\${{ env.SCRIPT_NAME }}.exe'),
                '/uc "' + ExpandConstant('{app}\myLoginUpdate\config.ini') + '" "' + 
                ExpandConstant('{app}\config.ini') + '"',
                '', SW_HIDE, ewWaitUntilTerminated, ResultCode
              );
            end;
            
            if DirExists(ExpandConstant('{app}\myLoginUpdate\lang')) then
            begin
              LangPath := ExpandConstant('{app}\lang\');
              TmpLangPath := ExpandConstant('{app}\myLoginUpdate\lang\');
              
              // Process each .txt file in the temporary lang directory
              if FindFirst(TmpLangPath + '*.txt', FindRec) then
              begin
                try
                  repeat
                    if (FindRec.Name <> '.') and (FindRec.Name <> '..') then
                    begin
                      Exec(
                        ExpandConstant('{app}\${{ env.SCRIPT_NAME }}.exe'),
                        '/uc "' + TmpLangPath + FindRec.Name + '" "' + 
                        LangPath + FindRec.Name + '"',
                        '', SW_HIDE, ewWaitUntilTerminated, ResultCode
                      );
                    end;
                  until not FindNext(FindRec);
                finally
                  FindClose(FindRec);
                end;
              end;
            end;
          end;
        end;
        "@
        Set-Content -Path "$env:GITHUB_WORKSPACE\setup.iss" -Value $issContent

    - name: Compile Inno Setup installer
      uses: Minionguyjpro/Inno-Setup-Action@v1.2.6
      with:
        path: setup.iss
        options: /Q

######################################################################### SignPath setup

    - name: Sign setup with SignPath
      if: env.ENABLE_SIGNPATH == 'true'
      run: |
        # Install the SignPath PowerShell module if it is not present
        if (-not (Get-Module -ListAvailable -Name SignPath)) {
          Install-Module -Name SignPath -Force -Scope CurrentUser -AllowClobber
        }
        Import-Module SignPath
        
        # Send signature request SETUP
        try {
          Submit-SigningRequest `
            -InputArtifactPath "${{ env.SCRIPT_NAME }}${{ env.NEW_VERSION }}_Setup.exe" `
            -ApiToken "${{ secrets.SIGNPATH_TOKEN }}" `
            -OrganizationId "${{ secrets.SIGNPATH_ORG_ID }}" `
            -ProjectSlug "${{ env.SCRIPT_NAME }}" `
            -SigningPolicySlug "${{ env.SCRIPT_NAME }}" `
            -OutputArtifactPath "${{ env.SCRIPT_NAME }}${{ env.NEW_VERSION }}_Setup.signed.exe" `
            -WaitForCompletion

          # Replace the unsigned executable with the signed one
          Move-Item -Path "${{ env.SCRIPT_NAME }}${{ env.NEW_VERSION }}_Setup.signed.exe" -Destination "${{ env.SCRIPT_NAME }}${{ env.NEW_VERSION }}_Setup.exe" -Force
          echo "::notice::Setup signed successfully"
        } catch {
          echo "::error::Failed to sign setup: $_"
          exit 1
        }
        
######################################################################### GPG signature

    - name: Sign setup with GPG
      run: |
        # Import private key
        echo "${{ secrets.GPG_PRIVATE_KEY }}" | gpg --batch --import
        
        # Sign the executable
        gpg --batch --yes --pinentry-mode loopback `
          --passphrase "${{ secrets.GPG_PASSPHRASE }}" `
          --local-user "${{ secrets.GPG_KEY_ID }}" `
          --output "${{ env.SCRIPT_NAME }}${{ env.NEW_VERSION }}_Setup.exe.sig" `
          --detach-sig "${{ env.SCRIPT_NAME }}${{ env.NEW_VERSION }}_Setup.exe"
        
        # Verify the signature
        gpg --verify "${{ env.SCRIPT_NAME }}${{ env.NEW_VERSION }}_Setup.exe.sig" "${{ env.SCRIPT_NAME }}${{ env.NEW_VERSION }}_Setup.exe"
        
        if ($LASTEXITCODE -ne 0) {
          echo "::error::GPG signature verification failed"
          exit 1
        }
        
######################################################################### compress files

    - name: Create ZIP Portable
      run: 7z a -tzip -bd -mx=9 "${{ env.SCRIPT_NAME }}${{ env.NEW_VERSION }}_Portable.zip" "${{ env.SCRIPT_NAME }}.exe" "$env:GITHUB_WORKSPACE\${{ env.SCRIPT_PATH }}config.ini" "$env:GITHUB_WORKSPACE\${{ env.SCRIPT_PATH }}lang"
      
######################################################################### compress files (optional)

    #- name: Upload artifact
    #  uses: actions/upload-artifact@v4
    #  with:
    #    name: ${{ env.SCRIPT_NAME }}${{ env.NEW_VERSION }}_Portable
    #    path: |
    #      ${{ env.SCRIPT_NAME }}.exe
    #      $env:GITHUB_WORKSPACE\${{ env.SCRIPT_PATH }}config.ini
    #      $env:GITHUB_WORKSPACE\${{ env.SCRIPT_PATH }}lang/*.txt

######################################################################### config. git/gpg/commit/tag

    - name: Config. Git/GPG/Commit/Tag
      run: |
        # Configure GPG to sign commits
        git config --global user.signingkey "${{ secrets.GPG_KEY_ID }}"
        git config --global commit.gpgsign true
        git config --global tag.gpgsign true

        # Configure the name and email for the commits
        #git config --global user.name "GitHub Actions"
        #git config --global user.email "actions@github.com"
        git config --global user.name "mlibre2"
        git config --global user.email "112137590+mlibre2@users.noreply.github.com"
        
        # Commit changes
        git add "${{ env.SCRIPT_PATH }}${{ env.SCRIPT_NAME }}.au3"
        
        # -m = "actions-user" / -S = forces signing "redundant if commit.gpgsign=true, but useful for debugging"
        git commit -S -m "⬆️ Auto-update version to ${{ env.NEW_VERSION }} [skip ci]"
        git push origin HEAD:main
        
        # Create tag (-a = "actions-user" / -s = create a tag signed with GPG key)
        git tag -s "${{ env.NEW_VERSION }}" -m "${{ env.NEW_VERSION }}"
        git push origin "${{ env.NEW_VERSION }}"

######################################################################### create Release

    - name: Create GitHub Release
      uses: softprops/action-gh-release@v2
      env:
        GITHUB_TOKEN: ${{ secrets.AUTOIT_DEPLOY_TOKEN }}
      with:
        tag_name: ${{ env.NEW_VERSION }}
        files: |
          ${{ env.SCRIPT_NAME }}${{ env.NEW_VERSION }}_Portable.zip
          ${{ env.SCRIPT_NAME }}${{ env.NEW_VERSION }}_Setup.exe
          ${{ env.SCRIPT_NAME }}${{ env.NEW_VERSION }}_Setup.exe.sig

######################################################################### virustotal

    - name: Analyze URL with VirusTotal
      if: env.ENABLE_VIRUSTOTAL == 'true'
      run: |
        # Reusable function to analyze URLs in VirusTotal
        function Analyze-VirusTotalURL {
            param(
                [string]$UrlToAnalyze
            )
            
            # Headers API v3
            $headers = @{
              "x-apikey" = "${{ secrets.VIRUSTOTAL_API_KEY }}"
              "Accept" = "application/json"
              "Content-Type" = "application/x-www-form-urlencoded"
            }
            
            try {
              # Correctly encode the URL for the request body
              $encodedUrl = [System.Web.HttpUtility]::UrlEncode($UrlToAnalyze)
              $postParams = "url=$encodedUrl"
              
              # Send POST request
              $response = Invoke-RestMethod -Uri "https://www.virustotal.com/api/v3/urls" `
                                           -Method Post `
                                           -Headers $headers `
                                           -Body $postParams
                                           
              # Process the response
              $analysisId = $response.data.id
    
              # Removes 'u-' prefix and numeric suffix
              $urlId = $analysisId -replace '^u-|-\d+$'
              
              # Build report URL
              $VT_GUI_URL = "https://www.virustotal.com/gui/url/$urlId"
              
              return $VT_GUI_URL
              
            } catch {
              # Detailed error handling
              $errorDetails = $_
              if ($_.Exception.Response) {
                $streamReader = [System.IO.StreamReader]::new($_.Exception.Response.GetResponseStream())
                $errorResponse = $streamReader.ReadToEnd() | ConvertFrom-Json
                $streamReader.Close()
                Write-Error "VirusTotal API Error: $($errorResponse.error.message)"
              } else {
                Write-Error "Error general: $($errorDetails.Exception.Message)"
              }
              exit 1
            }
        }
        
        # Analyze the first
        $ZIP_URL = "https://github.com/${{ github.repository }}/releases/download/${{ env.NEW_VERSION }}/${{ env.SCRIPT_NAME }}${{ env.NEW_VERSION }}_Portable.zip"
        $zipResult = Analyze-VirusTotalURL -UrlToAnalyze $ZIP_URL
        
        # Analyze the second
        $SETUP_URL = "https://github.com/${{ github.repository }}/releases/download/${{ env.NEW_VERSION }}/${{ env.SCRIPT_NAME }}${{ env.NEW_VERSION }}_Setup.exe"
        $setupResult = Analyze-VirusTotalURL -UrlToAnalyze $SETUP_URL
        
        # Save both results in environment variables
        Add-Content -Path $env:GITHUB_ENV -Value "VT_ZIP_URL=$zipResult"
        Add-Content -Path $env:GITHUB_ENV -Value "VT_SETUP_URL=$setupResult"

######################################################################### get commit message

    - name: Get/Save commit msg
      run: |
        $commitMsg = "${{ github.event.head_commit.message }}"

        # split a text string into multiple parts using line breaks as separators
        $lines = $commitMsg -split "`n" # `n represents the line break character

        # Cleaning up empty lines and whitespace
        $lines = $lines | Where-Object { $_ -ne "" } | ForEach-Object { $_.Trim() }

        #  debug...
        #  $lines[0] = "Update myLogin.au3"
        #  $lines[1] = "" (empty line)
        #  $lines[2] = "Fixed special"
        #  $lines[3] = "" (empty line)
        #  $lines[4] = "- New update"
        #  $lines[5] = "- Fixed lines"
        
        # Initialize variables
        $title = ""
        $description = ""
        
        # Only proceed if there are enough lines
        if ($lines -and $lines.Count -ge 3) {
            $title = $lines[2]
            
            if ($lines.Count -ge 5) {
                $description = $lines[4..($lines.Count-1)] -join "`n"
            }
        }

        # Only set environment variables if title exists
        if ($title) {
            "COMMIT_TITLE=$($title -replace "`n", " ")" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
            "COMMIT_DESCRIPTION<<EOF" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
            $description | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
            "EOF" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
        }
        
######################################################################### update release notes

    - name: Update release notes
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.AUTOIT_DEPLOY_TOKEN }}
        script: |
          // Get the existing release by tag
          const { data: release } = await github.rest.repos.getReleaseByTag({
            owner: context.repo.owner,
            repo: context.repo.repo,
            tag: process.env.NEW_VERSION
          });
          
          // Build the new body
          const newBody = `
          # :building_construction: ${process.env.COMMIT_TITLE} <img align="right" width="32" height="32" alt="Ico" src="https://github.com/user-attachments/assets/c8c08b6a-927c-4278-917a-c23b10e6491d" />
          
          ${process.env.COMMIT_DESCRIPTION}
          
          ## :recycle: Full Changelog
          
          - Versions: [\`${process.env.OLD_VERSION}...${process.env.NEW_VERSION}\`](https://github.com/${context.repo.owner}/${context.repo.repo}/compare/${process.env.OLD_VERSION}...${process.env.NEW_VERSION})
          
          ## :inbox_tray: Downloads
          
          [![GitHub Downloads (specific asset, specific tag)](https://img.shields.io/github/downloads/${context.repo.owner}/${context.repo.repo}/${process.env.NEW_VERSION}/${process.env.SCRIPT_NAME}${process.env.NEW_VERSION}_Portable.zip?style=for-the-badge&label=portable)](https://github.com/${context.repo.owner}/${context.repo.repo}/releases/download/${process.env.NEW_VERSION}/${process.env.SCRIPT_NAME}${process.env.NEW_VERSION}_Portable.zip) [<img src="https://img.shields.io/badge/Security%20vendors'%20analysis-432eff?style=for-the-badge&logo=virustotal">](${process.env.VT_ZIP_URL}?nocache=1)

          [![GitHub Downloads (specific asset, specific tag)](https://img.shields.io/github/downloads/${context.repo.owner}/${context.repo.repo}/${process.env.NEW_VERSION}/${process.env.SCRIPT_NAME}${process.env.NEW_VERSION}_Setup.exe?style=for-the-badge&label=installer)](https://github.com/${context.repo.owner}/${context.repo.repo}/releases/download/${process.env.NEW_VERSION}/${process.env.SCRIPT_NAME}${process.env.NEW_VERSION}_Setup.exe) [<img src="https://img.shields.io/badge/Security%20vendors'%20analysis-432eff?style=for-the-badge&logo=virustotal">](${process.env.VT_SETUP_URL}?nocache=1)
          `;
          
          // Update release
          await github.rest.repos.updateRelease({
            owner: context.repo.owner,
            repo: context.repo.repo,
            release_id: release.id,
            body: newBody
          });


######################################################################### add reactions
      
    - name: Add random reactions to release
      uses: actions/github-script@v7
      with:
        script: |
          const { data: release } = await github.rest.repos.getReleaseByTag({
            owner: context.repo.owner,
            repo: context.repo.repo,
            tag: '${{ env.NEW_VERSION }}'
          });
          
          // Reactions allowed by GitHub API for releases
          const reactions = ['+1', 'heart', 'hooray', 'rocket', 'eyes', 'laugh']
            .sort(() => Math.random() - 0.5)  // Shuffle array
            .slice(0, 2);  // Take first 2 elements
            
          console.log(`Adding reactions: ${reactions.join(' ... ')}`);
          
          // Add reactions in parallel
          await Promise.all(reactions.map(content => 
            github.rest.reactions.createForRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: release.id,
              content
            })
          ));
