name: Compile AutoIt Script

on:
  push:
    branches: [ main ]
    paths:
      - 'src/**/*.au3'

######################################################################### repo permissions (no token)

#permissions:
#  contents: write

######################################################################### jobs

jobs:
  compile:
    runs-on: windows-2025
    timeout-minutes: 5    # Maximum compilation time
    env:
      SCRIPT_NAME: myLogin
      SCRIPT_PATH: 'src'
      SCRIPT_ICON: 'compile_manual/Threat.contrast-white.ico'
      ENABLE_SIGNPATH: 'true'
      ENABLE_VIRUSTOTAL: 'true'
      
    steps:
######################################################################### checkout
    - name: Checkout code
      uses: actions/checkout@v5
      with:
        token: ${{ secrets.AUTOIT_DEPLOY_TOKEN }}
        # Download only the necessary files
        sparse-checkout: |
          ${{ env.SCRIPT_PATH }}/
          ${{ env.SCRIPT_ICON }}
        # no requerid
        ssh-strict: false
        show-progress: false
            
######################################################################### get upd/version

    - name: Get/Update version AU3
      run: |
        filePath="${{ env.SCRIPT_PATH }}\${{ env.SCRIPT_NAME }}.au3"
        
        # Verify that the file exists
        if [ ! -f "$filePath" ]; then
          echo "::error::File not found: $filePath"
          exit 1
        fi
        
        # Temporarily convert to LF for processing (we'll save with CRLF at the end)
        tempContent=$(cat "$filePath" | tr -d '\r')
        
        # Extract current version
        if [[ ! "$tempContent" =~ Const[[:space:]]+\$g_sVersion[[:space:]]*=[[:space:]]*\"([0-9]+)\.([0-9]+)\" ]]; then
          echo "::error::Version pattern not found in $filePath"
          echo "::debug::Line with version:"
          echo "$tempContent" | grep -m1 "Const \$g_sVersion" || echo "Not found"
          exit 1
        fi
        
        major=${BASH_REMATCH[1]}
        minor=${BASH_REMATCH[2]}
        old_version="${major}.${minor}"
        
        # Calculate new version
        if (( minor >= 9 )); then
          newVersion="$((major + 1)).0"
        else
          newVersion="${major}.$((minor + 1))"
        fi
        
        # Update CONST y pragmas
        updatedContent=$(echo "$tempContent" | \
        awk -v new="$newVersion" '
          /Const[[:space:]]+\$g_sVersion[[:space:]]*=/ {sub(/"([0-9]+\.){1}[0-9]+"/, "\"" new "\"")}
          {print}' | \
        sed -E "s/(#pragma compile\((ProductVersion|FileVersion),[[:space:]]*)[0-9]+\.[0-9]+(\))/\1${newVersion}\3/g")
        
        # Restore CRLF and write the file
        echo "$updatedContent" | sed 's/$/\r/' > "$filePath"

        echo "::notice:: Old: ${old_version}"
        echo "::warning:: New: $newVersion"
        
        # Export environment variables
        echo "OLD_VERSION=${old_version}" >> $GITHUB_ENV
        echo "NEW_VERSION=$newVersion" >> $GITHUB_ENV
      shell: bash
        
######################################################################### autoit setup

    - name: Download/Install AutoIt
      run: |
        echo "Downloading AutoIt..."
        curl -L -o "%tmp%\autoit.zip" "https://www.autoitscript.com/cgi-bin/getfile.pl?autoit3/autoit-v3.zip"
        echo "Unzip AutoIt..."
        7z x "%tmp%\autoit.zip" -o"%tmp%\"
        set "_AUT2EXE_=%tmp%\install\Aut2Exe\Aut2Exe.exe"
        echo ::warning::Env: %_AUT2EXE_%
        echo _AUT2EXE_=%_AUT2EXE_% >> %GITHUB_ENV%
      shell: cmd
        
######################################################################### compile au3/exe

    - name: Compile AU3 with Aut2Exe
      run: |
        echo "Verifying files... %SCRIPT_PATH%\%SCRIPT_NAME%.au3"
        
        set scriptPath=%SCRIPT_PATH%\%SCRIPT_NAME%.au3
        set outputPath=%SCRIPT_NAME%.exe
        
        if not exist "%scriptPath%" (
            echo ::error::Script not found at %scriptPath%
            exit /b 1
        )
        
        if not exist "%_AUT2EXE_%" (
            echo ::error::FAIL: %_AUT2EXE_%
            exit /b 1
        )
        
        echo "Compiling... %scriptPath%"
        "%_AUT2EXE_%" /in "%scriptPath%" /out "%outputPath%" /icon "%SCRIPT_ICON%" /comp 0 /nopack
        
        if not exist "%outputPath%" (
            echo ::error::Compilation failed - No output file created
            exit /b 1
        )
        
        echo ::warning::Compilation successful %outputPath%
      shell: cmd

######################################################################### SignPath executable

    - name: Sign executable with SignPath
      if: env.ENABLE_SIGNPATH == 'true'
      run: |
        # Install the SignPath PowerShell module if it is not present
        if (-not (Get-Module -ListAvailable -Name SignPath)) {
          Install-Module -Name SignPath -Force -Scope CurrentUser -AllowClobber
        }
        Import-Module SignPath
        
        # Send signature request EXE
        try {
          Submit-SigningRequest `
            -InputArtifactPath "${{ env.SCRIPT_NAME }}.exe" `
            -ApiToken "${{ secrets.SIGNPATH_TOKEN }}" `
            -OrganizationId "${{ secrets.SIGNPATH_ORG_ID }}" `
            -ProjectSlug "${{ env.SCRIPT_NAME }}" `
            -SigningPolicySlug "${{ env.SCRIPT_NAME }}" `
            -OutputArtifactPath "${{ env.SCRIPT_NAME }}.signed.exe" `
            -WaitForCompletion

          # Replace the unsigned executable with the signed one
          Move-Item -Path "${{ env.SCRIPT_NAME }}.signed.exe" -Destination "${{ env.SCRIPT_NAME }}.exe" -Force
          echo "::notice::Executable signed successfully"
        } catch {
          echo "::error::Failed to sign executable: $_"
          exit 1
        }

######################################################################### Install Inno

    - name: Download/Install Inno Setup
      run: |
        echo "Checking pre-installation..."

        set "ISCC_PATH=%programfiles(x86)%\Inno Setup 6\ISCC.exe"
        
        if exist "%ISCC_PATH%" (
          echo ::warning::Inno Setup is already installed
          exit /b 0
        )
        
        echo "Downloading Inno Setup..."

        set "_url_=https://jrsoftware.org/download.php/is.exe?site=1"
        set "_file_=innosetup.exe"

        curl -L -o "%tmp%\%_file_%" "%_url_%"
        
        echo "Installing Inno Setup..."
        "%tmp%\%_file_%" /VERYSILENT /SUPPRESSMSGBOXES /NORESTART /SP-
        
        if not exist "%ISCC_PATH%" (
          echo "::error::Inno Setup installation failed"
          exit 1
        )
        
        echo ::warning::Inno Setup installed successfully!
      shell: cmd

######################################################################### ISS

    - name: Generate ISS
      run: |
        cat << EOF > setup.iss
        [Setup]
        AppName=${{ env.SCRIPT_NAME }}
        AppVersion=${{ env.NEW_VERSION }}
        VersionInfoVersion=${{ env.NEW_VERSION }}.0.0
        AppVerName=${{ env.SCRIPT_NAME }} v${{ env.NEW_VERSION }}
        AppComments=${{ env.SCRIPT_NAME }} - Inno Setup
        AppCopyright=© by mlibre2 - Open source project on GitHub
        DefaultDirName={autopf}\${{ env.SCRIPT_NAME }}
        DefaultGroupName=${{ env.SCRIPT_NAME }}
        AppPublisher=GitHub@mlibre2
        AppPublisherURL=https://github.com/${{ github.repository }}/
        AppReadmeFile=https://github.com/${{ github.repository }}/blob/main/README.md
        AppSupportURL=https://github.com/${{ github.repository }}/issues
        AppUpdatesURL=https://github.com/${{ github.repository }}/releases
        DisableWelcomePage=no
        DisableProgramGroupPage=yes
        OutputDir=.
        OutputBaseFilename=${{ env.SCRIPT_NAME }}${{ env.NEW_VERSION }}_Setup
        SolidCompression=yes
        SetupIconFile=${{ env.SCRIPT_ICON }}
        ShowLanguageDialog=yes

        [Languages]
        Name: "en"; MessagesFile: "compiler:Default.isl"
        Name: "es"; MessagesFile: "compiler:Languages\Spanish.isl"

        [Tasks]
        Name: desktopicon; Description: "{cm:CreateDesktopIcon}"; GroupDescription: "{cm:AdditionalIcons}"; Flags: unchecked
        
        [Dirs]
        Name: "{app}"; Permissions: users-modify
        
        [Files]
        Source: "${{ env.SCRIPT_NAME }}.exe"; DestDir: "{app}"; Flags: ignoreversion
        Source: "${{ env.SCRIPT_PATH }}\config.ini"; DestDir: "{app}"; Flags: onlyifdoesntexist
        Source: "${{ env.SCRIPT_PATH }}\lang\*"; DestDir: "{app}\lang"; Flags: recursesubdirs onlyifdoesntexist

        ; Temporary files for upgrade (only copied if it is an upgrade)
        Source: "${{ env.SCRIPT_PATH }}\config.ini"; DestDir: "{app}\myLoginUpdate"; Flags: ignoreversion; Check: IsUpgrade
        Source: "${{ env.SCRIPT_PATH }}\lang\*"; DestDir: "{app}\myLoginUpdate\lang"; Flags: ignoreversion recursesubdirs; Check: IsUpgrade

        [Icons]
        Name: "{commondesktop}\${{ env.SCRIPT_NAME }}"; Filename: "{app}\${{ env.SCRIPT_NAME }}.exe"; Comment: "${{ env.SCRIPT_NAME }}"; Tasks: desktopicon
        
        [Run]
        Filename: "{app}\${{ env.SCRIPT_NAME }}.exe"; Flags: postinstall nowait skipifsilent
        
        [UninstallRun]
        Filename: "{app}\${{ env.SCRIPT_NAME }}.exe"; Parameters: "/uninstall"; RunOnceId: "${{ env.SCRIPT_NAME }}Uninstaller"
        
        [Code]
        var
          IsUpgradeMode: Boolean;

        function InitializeSetup(): Boolean;
        begin
          IsUpgradeMode := RegKeyExists(HKLM, 'Software\Microsoft\Windows\CurrentVersion\Uninstall\${{ env.SCRIPT_NAME }}_is1');
          Result := True;
        end;
        
        function IsUpgrade: Boolean;
        begin
          Result := IsUpgradeMode;
        end;

        procedure CurStepChanged(CurStep: TSetupStep);
        var
          ResultCode: Integer;
          FindRec: TFindRec;
          LangPath: String;
          TmpLangPath: String;
        begin
          if (CurStep = ssPostInstall) and IsUpgrade then
          begin
            // Only run if temporary files exist
            if FileExists(ExpandConstant('{app}\myLoginUpdate\config.ini')) then
            begin
              Exec(
                ExpandConstant('{app}\${{ env.SCRIPT_NAME }}.exe'),
                '/uc "' + ExpandConstant('{app}\myLoginUpdate\config.ini') + '" "' + 
                ExpandConstant('{app}\config.ini') + '"',
                '', SW_HIDE, ewWaitUntilTerminated, ResultCode
              );
            end;
            
            if DirExists(ExpandConstant('{app}\myLoginUpdate\lang')) then
            begin
              LangPath := ExpandConstant('{app}\lang\');
              TmpLangPath := ExpandConstant('{app}\myLoginUpdate\lang\');
              
              // Process each .txt file in the temporary lang directory
              if FindFirst(TmpLangPath + '*.txt', FindRec) then
              begin
                try
                  repeat
                    if (FindRec.Name <> '.') and (FindRec.Name <> '..') then
                    begin
                      Exec(
                        ExpandConstant('{app}\${{ env.SCRIPT_NAME }}.exe'),
                        '/uc "' + TmpLangPath + FindRec.Name + '" "' + 
                        LangPath + FindRec.Name + '"',
                        '', SW_HIDE, ewWaitUntilTerminated, ResultCode
                      );
                    end;
                  until not FindNext(FindRec);
                finally
                  FindClose(FindRec);
                end;
              end;
            end;
          end;
        end;
        EOF
      shell: bash

######################################################################### Compile Inno

    - name: Compile Inno Setup installer
      run: |
        echo "Compiling Inno Setup..."
        "%programfiles(x86)%\Inno Setup 6\ISCC.exe" /Q "setup.iss"
         
        if not exist "${{ env.SCRIPT_NAME }}${{ env.NEW_VERSION }}_Setup.exe" (
          echo "::error::Inno Setup compilation failed - No output file created"
          exit /b 1
        )
        echo ::warning::Successful compilation ${{ env.SCRIPT_NAME }}${{ env.NEW_VERSION }}_Setup.exe
      shell: cmd

######################################################################### SignPath setup

    - name: Sign setup with SignPath
      if: env.ENABLE_SIGNPATH == 'true'
      run: |
        # Install the SignPath PowerShell module if it is not present
        if (-not (Get-Module -ListAvailable -Name SignPath)) {
          Install-Module -Name SignPath -Force -Scope CurrentUser -AllowClobber
        }
        Import-Module SignPath
        
        # Send signature request SETUP
        try {
          Submit-SigningRequest `
            -InputArtifactPath "${{ env.SCRIPT_NAME }}${{ env.NEW_VERSION }}_Setup.exe" `
            -ApiToken "${{ secrets.SIGNPATH_TOKEN }}" `
            -OrganizationId "${{ secrets.SIGNPATH_ORG_ID }}" `
            -ProjectSlug "${{ env.SCRIPT_NAME }}" `
            -SigningPolicySlug "${{ env.SCRIPT_NAME }}" `
            -OutputArtifactPath "${{ env.SCRIPT_NAME }}${{ env.NEW_VERSION }}_Setup.signed.exe" `
            -WaitForCompletion

          # Replace the unsigned executable with the signed one
          Move-Item -Path "${{ env.SCRIPT_NAME }}${{ env.NEW_VERSION }}_Setup.signed.exe" -Destination "${{ env.SCRIPT_NAME }}${{ env.NEW_VERSION }}_Setup.exe" -Force
          echo "::notice::Setup signed successfully"
        } catch {
          echo "::error::Failed to sign setup: $_"
          exit 1
        }
        
######################################################################### GPG signature

    - name: Sign setup with GPG
      run: |
        echo "${{ secrets.GPG_PRIVATE_KEY }}" | gpg --batch --import --passphrase "${{ secrets.GPG_PASSPHRASE }}"
        
        gpg --batch --yes --pinentry-mode loopback \
          --passphrase "${{ secrets.GPG_PASSPHRASE }}" \
          --local-user "${{ secrets.GPG_KEY_ID }}" \
          --output "${{ env.SCRIPT_NAME }}${{ env.NEW_VERSION }}_Setup.exe.sig" \
          --detach-sig "${{ env.SCRIPT_NAME }}${{ env.NEW_VERSION }}_Setup.exe"
        
        if [ $? -ne 0 ]; then
          echo "::error::GPG signature failed"
          exit 1
        fi
        
        gpg --verify "${{ env.SCRIPT_NAME }}${{ env.NEW_VERSION }}_Setup.exe.sig" "${{ env.SCRIPT_NAME }}${{ env.NEW_VERSION }}_Setup.exe"
        
        if [ $? -ne 0 ]; then
          echo "::error::GPG signature verification failed"
          exit 1
        fi
      shell: bash

######################################################################### Prepare files

    - name: Prepare files
      run: |
        mv "${{ env.SCRIPT_PATH }}\config.ini" .
        mv "${{ env.SCRIPT_PATH }}\lang" lang\
      shell: bash
        
######################################################################### compress files

    - name: Create ZIP Portable
      run: 7z a "${{ env.SCRIPT_NAME }}${{ env.NEW_VERSION }}_Portable.zip" "${{ env.SCRIPT_NAME }}.exe" "config.ini" "lang"
      shell: cmd
      
######################################################################### compress files (optional)

#    - name: Upload artifact
#      uses: actions/upload-artifact@v4
#      with:
#        name: ${{ env.SCRIPT_NAME }}${{ env.NEW_VERSION }}_Portable
#        path: |
#          ${{ env.SCRIPT_NAME }}.exe
#          config.ini
#          lang\

######################################################################### config. git/gpg/commit/tag

    - name: Config. Git/GPG/Commit/Tag
      run: |
        # Configure GPG to sign commits
        git config --global user.signingkey "${{ secrets.GPG_KEY_ID }}"
        git config --global commit.gpgsign true
        git config --global tag.gpgsign true

        # Configure the name and email for the commits
        #git config --global user.name "GitHub Actions"
        #git config --global user.email "actions@github.com"
        git config --global user.name "mlibre2"
        git config --global user.email "112137590+mlibre2@users.noreply.github.com"
        
        # Commit changes
        git add "${{ env.SCRIPT_PATH }}\${{ env.SCRIPT_NAME }}.au3"
        
        # -m = "actions-user" / -S = forces signing "redundant if commit.gpgsign=true, but useful for debugging"
        git commit -S -m "⬆️ Auto-update version to ${{ env.NEW_VERSION }} [skip ci]"
        git push origin HEAD:main
        
        # Create tag (-a = "actions-user" / -s = create a tag signed with GPG key)
        git tag -s "${{ env.NEW_VERSION }}" -m "${{ env.NEW_VERSION }}"
        git push origin "${{ env.NEW_VERSION }}"
      shell: bash

######################################################################### create Release

    - name: Create GitHub Release
      uses: softprops/action-gh-release@v2
      env:
        GITHUB_TOKEN: ${{ secrets.AUTOIT_DEPLOY_TOKEN }}
      with:
        tag_name: ${{ env.NEW_VERSION }}
        files: |
          ${{ env.SCRIPT_NAME }}${{ env.NEW_VERSION }}_Portable.zip
          ${{ env.SCRIPT_NAME }}${{ env.NEW_VERSION }}_Setup.exe
          ${{ env.SCRIPT_NAME }}${{ env.NEW_VERSION }}_Setup.exe.sig

######################################################################### virustotal

    - name: Analyze URL with VirusTotal
      if: env.ENABLE_VIRUSTOTAL == 'true'
      run: |
        # Reusable function to analyze URLs in VirusTotal
        function Analyze-VirusTotalURL {
            param(
                [string]$UrlToAnalyze
            )
            
            # Headers API v3
            $headers = @{
              "x-apikey" = "${{ secrets.VIRUSTOTAL_API_KEY }}"
              "Accept" = "application/json"
              "Content-Type" = "application/x-www-form-urlencoded"
            }
            
            try {
              # Correctly encode the URL for the request body
              $encodedUrl = [System.Web.HttpUtility]::UrlEncode($UrlToAnalyze)
              $postParams = "url=$encodedUrl"
              
              # Send POST request
              $response = Invoke-RestMethod -Uri "https://www.virustotal.com/api/v3/urls" `
                                           -Method Post `
                                           -Headers $headers `
                                           -Body $postParams
                                           
              # Process the response
              $analysisId = $response.data.id
    
              # Removes 'u-' prefix and numeric suffix
              $urlId = $analysisId -replace '^u-|-\d+$'
              
              # Build report URL
              $VT_GUI_URL = "https://www.virustotal.com/gui/url/$urlId"
              
              return $VT_GUI_URL
              
            } catch {
              # Detailed error handling
              $errorDetails = $_
              if ($_.Exception.Response) {
                $streamReader = [System.IO.StreamReader]::new($_.Exception.Response.GetResponseStream())
                $errorResponse = $streamReader.ReadToEnd() | ConvertFrom-Json
                $streamReader.Close()
                Write-Error "VirusTotal API Error: $($errorResponse.error.message)"
              } else {
                Write-Error "Error general: $($errorDetails.Exception.Message)"
              }
              exit 1
            }
        }
        
        # Analyze the first
        $ZIP_URL = "https://github.com/${{ github.repository }}/releases/download/${{ env.NEW_VERSION }}/${{ env.SCRIPT_NAME }}${{ env.NEW_VERSION }}_Portable.zip"
        $zipResult = Analyze-VirusTotalURL -UrlToAnalyze $ZIP_URL
        
        # Analyze the second
        $SETUP_URL = "https://github.com/${{ github.repository }}/releases/download/${{ env.NEW_VERSION }}/${{ env.SCRIPT_NAME }}${{ env.NEW_VERSION }}_Setup.exe"
        $setupResult = Analyze-VirusTotalURL -UrlToAnalyze $SETUP_URL
        
        # Save both results in environment variables
        Add-Content -Path $env:GITHUB_ENV -Value "VT_ZIP_URL=$zipResult"
        Add-Content -Path $env:GITHUB_ENV -Value "VT_SETUP_URL=$setupResult"

######################################################################### get commit message

    - name: Get/Save commit msg
      run: |
        msg=$(jq -r '.head_commit.message' <<< '${{ toJSON(github.event) }}')
        
        # Debug: display original message with line numbers
        echo "Original message:"
        echo "$msg" | awk '{print NR ": " $0}'
        echo "-------------------"
        
        # Extract line 3 as title
        title=$(echo "$msg" | awk 'NR==3')
        
        # Extract from line 5 as description
        description=$(echo "$msg" | awk 'NR>=5')
        
        # Debug: show what is extracted
        echo "Title ext: '$title'"
        echo "Descripción ext:"
        echo "$description"
        echo "-------------------"
        
        # Save to environment variables while maintaining Markdown formatting
        echo "COMMIT_TITLE=${title}" >> $GITHUB_ENV
        echo "COMMIT_DESCRIPTION<<EOF" >> $GITHUB_ENV
        echo "$description" >> $GITHUB_ENV
        echo "EOF" >> $GITHUB_ENV
      shell: bash
        
######################################################################### update release notes

    - name: Update release notes
      uses: actions/github-script@v8
      with:
        github-token: ${{ secrets.AUTOIT_DEPLOY_TOKEN }}
        script: |
          // Get the existing release by tag
          const { data: release } = await github.rest.repos.getReleaseByTag({
            owner: context.repo.owner,
            repo: context.repo.repo,
            tag: process.env.NEW_VERSION
          });
          
          // Build the new body
          const newBody = `
          # :building_construction: ${process.env.COMMIT_TITLE} <img align="right" width="32" height="32" alt="Ico" src="https://github.com/user-attachments/assets/c8c08b6a-927c-4278-917a-c23b10e6491d" />
          
          ${process.env.COMMIT_DESCRIPTION}
          
          ## :recycle: Full Changelog
          
          - Versions: [\`${process.env.OLD_VERSION}...${process.env.NEW_VERSION}\`](https://github.com/${context.repo.owner}/${context.repo.repo}/compare/${process.env.OLD_VERSION}...${process.env.NEW_VERSION})
          
          ## :inbox_tray: Downloads
          
          [![GitHub Downloads (specific asset, specific tag)](https://img.shields.io/github/downloads/${context.repo.owner}/${context.repo.repo}/${process.env.NEW_VERSION}/${process.env.SCRIPT_NAME}${process.env.NEW_VERSION}_Portable.zip?style=for-the-badge&label=portable)](https://github.com/${context.repo.owner}/${context.repo.repo}/releases/download/${process.env.NEW_VERSION}/${process.env.SCRIPT_NAME}${process.env.NEW_VERSION}_Portable.zip) [<img src="https://img.shields.io/badge/Security%20vendors'%20analysis-432eff?style=for-the-badge&logo=virustotal">](${process.env.VT_ZIP_URL}?nocache=1)

          [![GitHub Downloads (specific asset, specific tag)](https://img.shields.io/github/downloads/${context.repo.owner}/${context.repo.repo}/${process.env.NEW_VERSION}/${process.env.SCRIPT_NAME}${process.env.NEW_VERSION}_Setup.exe?style=for-the-badge&label=installer)](https://github.com/${context.repo.owner}/${context.repo.repo}/releases/download/${process.env.NEW_VERSION}/${process.env.SCRIPT_NAME}${process.env.NEW_VERSION}_Setup.exe) [<img src="https://img.shields.io/badge/Security%20vendors'%20analysis-432eff?style=for-the-badge&logo=virustotal">](${process.env.VT_SETUP_URL}?nocache=1)
          `;
          
          // Update release
          await github.rest.repos.updateRelease({
            owner: context.repo.owner,
            repo: context.repo.repo,
            release_id: release.id,
            body: newBody
          });
