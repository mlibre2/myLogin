name: Get events

on:
  issues:
    types: [opened, reopened, closed]
  pull_request:
    types: [opened, reopened, closed]
  create:
    tags: ['*']

permissions:
  issues: write
  pull-requests: write
  contents: write

jobs:
  handle_events:
    runs-on: ubuntu-latest
    timeout-minutes: 2
    steps:
      - name: Manage different events
        uses: actions/github-script@v8
        with:
          script: |
            const { eventName, payload } = context;

            // Handle tag creation event (release)
            if (eventName === 'create' && payload.ref_type === 'tag') {
              const tagName = payload.ref;
              
              try {
                const { data: release } = await github.rest.repos.getReleaseByTag({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  tag: tagName
                });
                
                // Reactions allowed by GitHub API for releases
                const reactions = ['+1', 'heart', 'hooray', 'rocket', 'eyes', 'laugh']
                  .sort(() => Math.random() - 0.5)
                  .slice(0, 2);
                
                console.log(`Adding reactions to release ${tagName}: ${reactions.join(', ')}`);
                
                // Add reactions in parallel
                await Promise.all(reactions.map(content => 
                  github.rest.reactions.createForRelease({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    release_id: release.id,
                    content
                  })
                ));
                
                console.log('Reactions added successfully!');
                
              } catch (error) {
                if (error.status === 404) {
                  console.log(`No release found for tag ${tagName}, skipping reactions`);
                } else {
                  core.error(`Failed to add reactions: ${error}`);
                  throw error;
                }
              }
              return; // Exit script after handling tag
            }

            // Handle issues and pull request events
            const isPR = eventName === 'pull_request';
            const item = isPR ? payload.pull_request : payload.issue;

            // Verify we have the necessary item
            if (!item) {
              console.log(`No item found for event: ${eventName}`);
              return;
            }

            const repoData = await github.rest.repos.get({
              owner: context.repo.owner,
              repo: context.repo.repo
            });
            const repoCreator = repoData.data.owner.login;

            if (!repoCreator) {
              core.error('Could not get repository creator');
              return;
            }

            console.log(`Repository creator: ${repoCreator}`);

            // Configuration by type
            const config = {
              issue: {
                label: 'closed',
                messages: {
                  opened: `ðŸ“Œ Hello @${item.user.login}! Thanks for opening this issue. I've assigned @${repoCreator} for review.`,
                  reopened: `ðŸ”“ Issue reopened by @${payload.sender.login}. @${repoCreator} has been notified.`,
                  closed: `ðŸ”’ Issue closed by @${payload.sender.login}. Thank you for your contribution.`
                }
              },
              pr: {
                label: 'pr-closed',
                messages: {
                  opened: `ðŸ”„ Thank you @${item.user.login} for your Pull Request! I've assigned @${repoCreator} for review.`,
                  reopened: `ðŸ“Œ PR reopened by @${payload.sender.login}. @${repoCreator} has been notified.`,
                  closed: `âœ… PR closed by @${payload.sender.login}. ${item.merged ? 'Successfully merged!' : 'Closed without merging.'}`
                }
              }
            };

            const { label, messages } = config[isPR ? 'pr' : 'issue'];

            // Auto-assign to repo creator when opened/reopened
            if (['opened', 'reopened'].includes(payload.action)) {
              try {
                await github.rest.issues.addAssignees({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: item.number,
                  assignees: [repoCreator]
                });
                console.log(`Successfully assigned to @${repoCreator}`);
              } catch (error) {
                if (error.status === 403) {
                  console.log(`Cannot assign issues: Missing permissions. Skipping assignment.`);
                } else {
                  core.error(`Assignment error: ${error}`);
                  throw error;
                }
              }
            }

            // Label management
            if (payload.action === 'closed') {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: item.number,
                labels: [label]
              });
            } 
            else if (payload.action === 'reopened') {
              try {
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: item.number,
                  name: label
                });
              } catch (error) {
                if (error.status !== 404) throw error;
              }
            }

            // Contextual comment
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: item.number,
              body: messages[payload.action]
            });

            // Delete branch if PR was merged
            if (isPR && payload.action === 'closed' && item.merged && item.head && item.head.ref) {
              try {
                await github.rest.git.deleteRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: `heads/${item.head.ref}`
                });
                console.log(`Successfully deleted branch ${item.head.ref}`);
              } catch (error) {
                if (error.status !== 422) {
                  core.error(`Failed to delete branch: ${error}`);
                }
              }
            }
